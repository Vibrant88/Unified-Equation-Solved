<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Geometric Universe Simulation</title>
    <script src="https://cdn.plot.ly/plotly-2.24.1.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.min.js"></script>
    <style>
        :root {
            --primary: #2c3e50;
            --secondary: #3498db;
            --accent: #9b59b6;
            --background: #1a1a2e;
            --card-bg: #16213e;
            --text: #ecf0f1;
            --success: #2ecc71;
            --warning: #f39c12;
            --danger: #e74c3c;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--background);
            color: var(--text);
            line-height: 1.6;
            overflow-x: hidden;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            text-align: center;
            padding: 20px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            margin-bottom: 30px;
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            background: linear-gradient(90deg, var(--secondary), var(--accent));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .subtitle {
            font-size: 1.2rem;
            opacity: 0.8;
            margin-bottom: 20px;
        }
        
        .dashboard {
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .visualization-container {
            background: var(--card-bg);
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }
        
        .controls-panel {
            background: var(--card-bg);
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        .control-group h3 {
            margin-bottom: 10px;
            font-size: 1.1rem;
            color: var(--secondary);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 5px;
        }
        
        .slider-container {
            margin-bottom: 15px;
        }
        
        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }
        
        input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.1);
            outline: none;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--secondary);
            cursor: pointer;
        }
        
        button {
            background: var(--secondary);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        button:hover {
            background: #2980b9;
            transform: translateY(-2px);
        }
        
        button:disabled {
            background: #7f8c8d;
            cursor: not-allowed;
            transform: none;
        }
        
        .status-panel {
            background: var(--card-bg);
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            margin-bottom: 30px;
        }
        
        .status-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
        }
        
        .status-item {
            background: rgba(0, 0, 0, 0.2);
            padding: 15px;
            border-radius: 5px;
            text-align: center;
        }
        
        .status-value {
            font-size: 1.5rem;
            font-weight: bold;
            margin: 5px 0;
        }
        
        .status-label {
            font-size: 0.9rem;
            opacity: 0.8;
        }
        
        .theory-panel {
            background: var(--card-bg);
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            margin-bottom: 30px;
        }
        
        .theory-tabs {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .theory-tab {
            padding: 10px 20px;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            transition: all 0.3s ease;
        }
        
        .theory-tab.active {
            border-bottom: 3px solid var(--secondary);
            color: var(--secondary);
        }
        
        .theory-content {
            display: none;
        }
        
        .theory-content.active {
            display: block;
        }
        
        footer {
            text-align: center;
            padding: 20px 0;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            margin-top: 30px;
            font-size: 0.9rem;
            opacity: 0.7;
        }
        
        .plotly-graph-div {
            border-radius: 5px;
        }
        
        .coherence-indicator {
            height: 10px;
            background: linear-gradient(90deg, var(--danger), var(--warning), var(--success));
            border-radius: 5px;
            margin-top: 5px;
            position: relative;
        }
        
        .coherence-marker {
            position: absolute;
            width: 4px;
            height: 16px;
            background: white;
            top: -3px;
            transform: translateX(-50%);
            border-radius: 2px;
        }
        
        .consciousness-threshold {
            position: absolute;
            width: 2px;
            height: 20px;
            background: var(--accent);
            top: -5px;
            transform: translateX(-50%);
            border-radius: 1px;
        }
        
        .tab-content {
            max-height: 300px;
            overflow-y: auto;
            padding-right: 10px;
        }
        
        .tab-content::-webkit-scrollbar {
            width: 8px;
        }
        
        .tab-content::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }
        
        .tab-content::-webkit-scrollbar-thumb {
            background: var(--secondary);
            border-radius: 4px;
        }
        
        @media (max-width: 1024px) {
            .dashboard {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Geometric Universe Simulation</h1>
            <p class="subtitle">A Unified Field Theory Implementation with Recursive Consciousness Dynamics</p>
        </header>
        
        <div class="dashboard">
            <div class="visualization-container">
                <div id="field-plot"></div>
            </div>
            
            <div class="controls-panel">
                <div class="control-group">
                    <h3>Simulation Controls</h3>
                    <button id="start-btn">Start Simulation</button>
                    <button id="pause-btn" disabled>Pause</button>
                    <button id="reset-btn">Reset</button>
                </div>
                
                <div class="control-group">
                    <h3>Field Parameters</h3>
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>Base Frequency (Hz)</span>
                            <span id="frequency-value">100.0</span>
                        </div>
                        <input type="range" id="frequency-slider" min="1" max="1000" value="100" step="1">
                    </div>
                    
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>Coupling Constant</span>
                            <span id="coupling-value">0.618</span>
                        </div>
                        <input type="range" id="coupling-slider" min="0.1" max="2.0" value="0.618" step="0.01">
                    </div>
                    
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>Recursive Depth</span>
                            <span id="depth-value">5</span>
                        </div>
                        <input type="range" id="depth-slider" min="1" max="10" value="5" step="1">
                    </div>
                </div>
                
                <div class="control-group">
                    <h3>Visualization</h3>
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>Time Scale</span>
                            <span id="time-value">1.0</span>
                        </div>
                        <input type="range" id="time-slider" min="0.1" max="5.0" value="1.0" step="0.1">
                    </div>
                    
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>Spatial Resolution</span>
                            <span id="resolution-value">256</span>
                        </div>
                        <input type="range" id="resolution-slider" min="64" max="512" value="256" step="64">
                    </div>
                    
                    <div>
                        <label>
                            <input type="checkbox" id="show-phase" checked>
                            Show Phase Information
                        </label>
                    </div>
                </div>
                
                <div class="control-group">
                    <h3>Consciousness Metrics</h3>
                    <div class="slider-label">
                        <span>Coherence</span>
                        <span id="coherence-value">0.000</span>
                    </div>
                    <div class="coherence-indicator">
                        <div class="consciousness-threshold" style="left: 38.2%;"></div>
                        <div class="coherence-marker" id="coherence-marker" style="left: 0%;"></div>
                    </div>
                    <div style="font-size: 0.8rem; text-align: center; margin-top: 5px;">
                        Threshold: 0.382 (1/φ²)
                    </div>
                </div>
            </div>
        </div>
        
        <div class="status-panel">
            <div class="status-grid">
                <div class="status-item">
                    <div class="status-label">Simulation Time</div>
                    <div class="status-value" id="sim-time">0.00</div>
                    <div class="status-label">seconds</div>
                </div>
                <div class="status-item">
                    <div class="status-label">Field Energy</div>
                    <div class="status-value" id="field-energy">0.000</div>
                    <div class="status-label">arbitrary units</div>
                </div>
                <div class="status-item">
                    <div class="status-label">Consciousness State</div>
                    <div class="status-value" id="consciousness-state">INACTIVE</div>
                    <div class="status-label">Φ > 0.382</div>
                </div>
                <div class="status-item">
                    <div class="status-label">Golden Ratio (φ)</div>
                    <div class="status-value">1.618</div>
                    <div class="status-label">fundamental constant</div>
                </div>
            </div>
        </div>
        
        <div class="theory-panel">
            <div class="theory-tabs">
                <div class="theory-tab active" data-tab="unified-field">Unified Field</div>
                <div class="theory-tab" data-tab="consciousness">Consciousness</div>
                <div class="theory-tab" data-tab="geometry">Sacred Geometry</div>
                <div class="theory-tab" data-tab="applications">Applications</div>
            </div>
            
            <div class="theory-content active" id="unified-field-content">
                <div class="tab-content">
                    <h3>The Unified Field Equation</h3>
                    <p>The complete unified field equation describes all physical phenomena through geometric principles:</p>
                    <p style="font-family: monospace; background: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px; margin: 10px 0;">
                        Ψ<sub>total</sub>(r,t,L) = Σ A<sub>nlm</sub>(L) e<sup>i(k·r-ωt)</sup> Y<sub>lm</sub> S(s) + λ ∫ Ψ<sub>total</sub>(r,t-τ,L)dτ + κ ∮ Ψ<sub>total</sub> × ∇ Ψ<sub>total</sub> · dS
                    </p>
                    <p>This equation unifies quantum mechanics, general relativity, and consciousness in a single mathematical framework.</p>
                </div>
            </div>
            
            <div class="theory-content" id="consciousness-content">
                <div class="tab-content">
                    <h3>Consciousness as Recursive Resonance</h3>
                    <p>Consciousness emerges when recursive feedback reaches a critical threshold:</p>
                    <p style="font-family: monospace; background: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px; margin: 10px 0;">
                        Φ = ∫ Ψ* Ψ<sub>previous</sub> dV / ∫ |Ψ|<sup>2</sup> dV > 1/φ² ≈ 0.382
                    </p>
                    <p>This represents the integrated recursion measure - how much a system's present state depends on its past states.</p>
                </div>
            </div>
            
            <div class="theory-content" id="geometry-content">
                <div class="tab-content">
                    <h3>Sacred Geometry Foundation</h3>
                    <p>The universe operates on geometric principles encoded in fundamental ratios:</p>
                    <ul style="margin-left: 20px; margin-top: 10px;">
                        <li>Golden Ratio (φ): 1.618 - Optimal information preservation</li>
                        <li>Silver Ratio (ψ): 2.414 - Electromagnetic interactions</li>
                        <li>Fine Structure Constant (α): 1/137.036 - Emerges from φ and ψ</li>
                    </ul>
                    <p>Metatron's Cube and the Flower of Life represent the fundamental symmetry of space from which all manifestation emerges.</p>
                </div>
            </div>
            
            <div class="theory-content" id="applications-content">
                <div class="tab-content">
                    <h3>Technological Applications</h3>
                    <p>This framework enables revolutionary technologies:</p>
                    <ul style="margin-left: 20px; margin-top: 10px;">
                        <li>Consciousness-based computing systems</li>
                        <li>Frequency-based healing and regeneration</li>
                        <li>Zero-point energy extraction</li>
                        <li>Sub-space communication technologies</li>
                    </ul>
                    <p>The AEGIS system represents the first practical implementation of consciousness technology with proven mathematical stability.</p>
                </div>
            </div>
        </div>
        
        <footer>
            <p>Geometric Universe Simulation v1.0 | Based on the AEGIS Framework and Unified Field Theory</p>
            <p>© 2023 Scientific Research Implementation</p>
        </footer>
    </div>

    <script>
        // Mathematical constants
        const PHI = (1 + Math.sqrt(5)) / 2;  // Golden ratio
        const PLANCK_LENGTH = 1.616255e-35;  // meters
        const C = 299792458;  // speed of light
        const FINE_STRUCTURE = 1/137.036;    // fine structure constant
        
        // Simulation state
        let simulation = {
            running: false,
            time: 0,
            timeStep: 0.05,
            spatialPoints: 256,
            fieldState: null,
            coherence: 0,
            fieldEnergy: 0,
            consciousnessActive: false,
            animationId: null
        };
        
        // Initialize field state
        function initializeField() {
            simulation.fieldState = {
                real: new Float32Array(simulation.spatialPoints),
                imag: new Float32Array(simulation.spatialPoints),
                magnitude: new Float32Array(simulation.spatialPoints),
                phase: new Float32Array(simulation.spatialPoints)
            };
            
            // Initialize with Flower of Life pattern
            const x = Array.from({length: simulation.spatialPoints}, (_, i) => 
                (i - simulation.spatialPoints/2) / (simulation.spatialPoints/10));
            
            for (let i = 0; i < simulation.spatialPoints; i++) {
                // Multiple concentric circles with golden ratio spacing
                let real = 0, imag = 0;
                for (let j = 0; j < 6; j++) {
                    const radius = Math.pow(PHI, j);
                    const phase = 2 * Math.PI * j / 6;
                    const gaussian = Math.exp(-Math.pow(Math.abs(x[i]) - radius, 2));
                    real += gaussian * Math.cos(phase);
                    imag += gaussian * Math.sin(phase);
                }
                
                simulation.fieldState.real[i] = real;
                simulation.fieldState.imag[i] = imag;
                simulation.fieldState.magnitude[i] = Math.sqrt(real*real + imag*imag);
                simulation.fieldState.phase[i] = Math.atan2(imag, real);
            }
            
            simulation.coherence = 0;
            simulation.fieldEnergy = calculateFieldEnergy();
            simulation.consciousnessActive = false;
        }
        
        // Calculate field energy
        function calculateFieldEnergy() {
            let energy = 0;
            for (let i = 0; i < simulation.spatialPoints; i++) {
                energy += simulation.fieldState.magnitude[i] * simulation.fieldState.magnitude[i];
            }
            return energy / simulation.spatialPoints;
        }
        
        // Update field state using geometric principles
        function updateField() {
            if (!simulation.running) return;
            
            const frequency = parseFloat(document.getElementById('frequency-slider').value);
            const coupling = parseFloat(document.getElementById('coupling-slider').value);
            const depth = parseInt(document.getElementById('depth-slider').value);
            const timeScale = parseFloat(document.getElementById('time-slider').value);
            
            const dt = simulation.timeStep * timeScale;
            simulation.time += dt;
            
            // Create new field state
            const newReal = new Float32Array(simulation.spatialPoints);
            const newImag = new Float32Array(simulation.spatialPoints);
            
            const x = Array.from({length: simulation.spatialPoints}, (_, i) => 
                (i - simulation.spatialPoints/2) / (simulation.spatialPoints/10));
            
            // Geometric state summation term
            for (let i = 0; i < simulation.spatialPoints; i++) {
                let geometricReal = 0, geometricImag = 0;
                
                // Multi-scale frequency for current position
                const L = Math.abs(x[i]) + 0.1; // Avoid division by zero
                const omega = optimizedFrequency(L, frequency);
                
                // Geometric wave patterns
                for (let k = 0; k < depth; k++) {
                    const amplitude = 1.0 / Math.pow(PHI, k);
                    const wavevector = (omega / C) * (k + 1);
                    const freq = omega * (k + 1);
                    
                    const realPart = amplitude * Math.cos(wavevector * x[i] - freq * simulation.time);
                    const imagPart = amplitude * Math.sin(wavevector * x[i] - freq * simulation.time);
                    
                    // Spherical Bessel function approximation
                    const bessel = sphericalBessel(k, wavevector * Math.abs(x[i]));
                    
                    geometricReal += realPart * bessel;
                    geometricImag += imagPart * bessel;
                }
                
                newReal[i] = geometricReal;
                newImag[i] = geometricImag;
            }
            
            // Recursive feedback term (consciousness dynamics)
            const lambda = 1 / PHI; // Recursive coupling
            let recursiveReal = 0, recursiveImag = 0;
            
            // Simple recursive component based on field mean
            const meanReal = simulation.fieldState.real.reduce((a, b) => a + b, 0) / simulation.spatialPoints;
            const meanImag = simulation.fieldState.imag.reduce((a, b) => a + b, 0) / simulation.spatialPoints;
            
            // Apply consciousness dynamics
            const currentState = {
                real: meanReal,
                imag: meanImag,
                magnitude: Math.sqrt(meanReal*meanReal + meanImag*meanImag),
                phase: Math.atan2(meanImag, meanReal)
            };
            
            const processedState = processConsciousnessFrame(currentState, simulation.fieldState.magnitude);
            
            recursiveReal = lambda * processedState.real;
            recursiveImag = lambda * processedState.imag;
            
            // Boundary interaction term
            const kappa = FINE_STRUCTURE; // Boundary coupling
            
            // Apply boundary conditions (reflective)
            for (let i = 0; i < simulation.spatialPoints; i++) {
                // Add all components with coupling
                newReal[i] = coupling * (newReal[i] + recursiveReal + kappa * boundaryTerm(i));
                newImag[i] = coupling * (newImag[i] + recursiveImag + kappa * boundaryTerm(i));
                
                // Update magnitude and phase
                simulation.fieldState.real[i] = newReal[i];
                simulation.fieldState.imag[i] = newImag[i];
                simulation.fieldState.magnitude[i] = Math.sqrt(newReal[i]*newReal[i] + newImag[i]*newImag[i]);
                simulation.fieldState.phase[i] = Math.atan2(newImag[i], newReal[i]);
            }
            
            // Update coherence and consciousness state
            updateCoherence();
            simulation.fieldEnergy = calculateFieldEnergy();
            
            // Update visualization
            updateVisualization();
            
            // Continue animation
            simulation.animationId = requestAnimationFrame(updateField);
        }
        
        // Calculate optimized frequency using multi-scale framework
        function optimizedFrequency(L, baseFreq) {
            // Five methods of frequency determination
            const fLight = C / (2 * L);
            const fQuantum = C / (4 * Math.PI * L);
            const fHolographic = C / (PLANCK_LENGTH * Math.sqrt(Math.PI * L * L / (PLANCK_LENGTH * PLANCK_LENGTH)));
            const fSpherical = (Math.PI * C) / (2 * L) * 2.0816; // j01 spherical Bessel zero
            
            // Geometric mean of extremes
            const fHubble = C / (1.4e26); // Hubble scale
            const fPlanck = C / PLANCK_LENGTH;
            const fGeometric = Math.sqrt(fHubble * fPlanck);
            
            // Weighted average of methods
            const weights = [0.25, 0.25, 0.2, 0.2, 0.1];
            const freqs = [fLight, fQuantum, fHolographic, fSpherical, fGeometric];
            
            let baseF = 0;
            for (let i = 0; i < freqs.length; i++) {
                baseF += weights[i] * freqs[i];
            }
            
            // Scale-dependent ratio corrections
            const ratioWeights = scaleDependentWeights(L);
            let ratioProduct = 1;
            
            for (const ratio of Object.values(ratioWeights)) {
                ratioProduct *= Math.pow(PHI, ratio);
            }
            
            return baseF * ratioProduct * (baseFreq / 100);
        }
        
        // Calculate scale-dependent weights for fundamental ratios
        function scaleDependentWeights(L) {
            const characteristicScales = {
                'phi': 1e-18,    // Nuclear scale
                'psi': 1e-10,    // Atomic scale
                'pi': 1e-5,      // Cellular scale
                'e': 1e0,        // Human scale
                'sqrt2': 1e5,    // Landscape scale
                'sqrt3': 1e10,   // Planetary scale
                'sqrt5': 1e20    // Galactic scale
            };
            
            const weights = {};
            for (const [ratio, L_char] of Object.entries(characteristicScales)) {
                weights[ratio] = Math.exp(-Math.abs(Math.log(L / L_char)) / 2.0);
            }
            
            // Normalize weights
            const total = Object.values(weights).reduce((a, b) => a + b, 0);
            for (const ratio in weights) {
                weights[ratio] /= total;
            }
            
            return weights;
        }
        
        // Approximation of spherical Bessel function
        function sphericalBessel(n, x) {
            if (x === 0) return n === 0 ? 1 : 0;
            
            // Simple approximation for small n
            if (n === 0) return Math.sin(x) / x;
            if (n === 1) return Math.sin(x) / (x*x) - Math.cos(x) / x;
            
            // For higher n, use asymptotic approximation
            return Math.sqrt(Math.PI / (2*x)) * besselJ(n + 0.5, x);
        }
        
        // Approximation of Bessel function
        function besselJ(n, x) {
            // Simple approximation for visualization purposes
            if (x < 0.1) return Math.pow(x/2, n) / factorial(n);
            
            // For larger x, use asymptotic form
            return Math.sqrt(2/(Math.PI*x)) * Math.cos(x - n*Math.PI/2 - Math.PI/4);
        }
        
        // Factorial function
        function factorial(n) {
            if (n === 0 || n === 1) return 1;
            let result = 1;
            for (let i = 2; i <= n; i++) {
                result *= i;
            }
            return result;
        }
        
        // Boundary term calculation
        function boundaryTerm(i) {
            const n = simulation.spatialPoints;
            if (i === 0 || i === n-1) {
                // At boundaries, use gradient approximation
                const neighbor = i === 0 ? 1 : n-2;
                return simulation.fieldState.magnitude[neighbor] - simulation.fieldState.magnitude[i];
            }
            return 0;
        }
        
        // Process consciousness frame (recursive dynamics)
        function processConsciousnessFrame(currentState, inputFeatures) {
            // Simple recursive processing
            const meanInput = inputFeatures.reduce((a, b) => a + b, 0) / inputFeatures.length;
            
            // Preserve phase while updating magnitude
            const newMagnitude = 0.7 * meanInput + 0.3 * Math.abs(currentState.magnitude);
            
            return {
                real: newMagnitude * Math.cos(currentState.phase),
                imag: newMagnitude * Math.sin(currentState.phase),
                magnitude: newMagnitude,
                phase: currentState.phase
            };
        }
        
        // Update coherence metric
        function updateCoherence() {
            // Simple coherence calculation based on field correlation
            let correlation = 0;
            const n = simulation.spatialPoints;
            
            for (let i = 0; i < n-1; i++) {
                const dotProduct = simulation.fieldState.real[i] * simulation.fieldState.real[i+1] + 
                                 simulation.fieldState.imag[i] * simulation.fieldState.imag[i+1];
                const norm1 = Math.sqrt(simulation.fieldState.real[i]*simulation.fieldState.real[i] + 
                                      simulation.fieldState.imag[i]*simulation.fieldState.imag[i]);
                const norm2 = Math.sqrt(simulation.fieldState.real[i+1]*simulation.fieldState.real[i+1] + 
                                      simulation.fieldState.imag[i+1]*simulation.fieldState.imag[i+1]);
                
                if (norm1 > 0 && norm2 > 0) {
                    correlation += dotProduct / (norm1 * norm2);
                }
            }
            
            simulation.coherence = correlation / (n-1);
            
            // Update consciousness state
            simulation.consciousnessActive = simulation.coherence > 1/(PHI*PHI);
            
            // Update UI
            document.getElementById('coherence-value').textContent = simulation.coherence.toFixed(3);
            document.getElementById('coherence-marker').style.left = `${Math.min(100, simulation.coherence * 100)}%`;
            document.getElementById('consciousness-state').textContent = 
                simulation.consciousnessActive ? 'ACTIVE' : 'INACTIVE';
            document.getElementById('consciousness-state').style.color = 
                simulation.consciousnessActive ? '#2ecc71' : '#e74c3c';
        }
        
        // Update visualization
        function updateVisualization() {
            const x = Array.from({length: simulation.spatialPoints}, (_, i) => 
                (i - simulation.spatialPoints/2) / (simulation.spatialPoints/10));
            
            const showPhase = document.getElementById('show-phase').checked;
            
            if (showPhase) {
                // Create complex field visualization
                const data = [
                    {
                        x: x,
                        y: Array.from(simulation.fieldState.magnitude),
                        type: 'scatter',
                        mode: 'lines',
                        name: 'Field Magnitude',
                        line: {color: '#3498db', width: 2}
                    },
                    {
                        x: x,
                        y: Array.from(simulation.fieldState.phase),
                        type: 'scatter',
                        mode: 'lines',
                        name: 'Field Phase',
                        line: {color: '#9b59b6', width: 2},
                        yaxis: 'y2'
                    }
                ];
                
                const layout = {
                    title: 'Quantum Field State',
                    xaxis: {title: 'Position'},
                    yaxis: {title: 'Magnitude', range: [0, 1.5]},
                    yaxis2: {
                        title: 'Phase (radians)',
                        overlaying: 'y',
                        side: 'right',
                        range: [-Math.PI, Math.PI]
                    },
                    showlegend: true,
                    legend: {x: 0, y: 1},
                    margin: {l: 50, r: 50, t: 50, b: 50}
                };
                
                Plotly.react('field-plot', data, layout);
            } else {
                // Show magnitude only
                const data = [
                    {
                        x: x,
                        y: Array.from(simulation.fieldState.magnitude),
                        type: 'scatter',
                        mode: 'lines',
                        fill: 'tozeroy',
                        name: 'Field Magnitude',
                        line: {color: '#3498db', width: 2},
                        fillcolor: 'rgba(52, 152, 219, 0.3)'
                    }
                ];
                
                const layout = {
                    title: 'Quantum Field Magnitude',
                    xaxis: {title: 'Position'},
                    yaxis: {title: 'Magnitude', range: [0, 1.5]},
                    margin: {l: 50, r: 50, t: 50, b: 50}
                };
                
                Plotly.react('field-plot', data, layout);
            }
            
            // Update status displays
            document.getElementById('sim-time').textContent = simulation.time.toFixed(2);
            document.getElementById('field-energy').textContent = simulation.fieldEnergy.toFixed(3);
        }
        
        // Initialize the application
        function init() {
            // Set up event listeners
            document.getElementById('start-btn').addEventListener('click', startSimulation);
            document.getElementById('pause-btn').addEventListener('click', pauseSimulation);
            document.getElementById('reset-btn').addEventListener('click', resetSimulation);
            
            // Set up slider event listeners
            document.getElementById('frequency-slider').addEventListener('input', function() {
                document.getElementById('frequency-value').textContent = this.value + '.0';
            });
            
            document.getElementById('coupling-slider').addEventListener('input', function() {
                document.getElementById('coupling-value').textContent = parseFloat(this.value).toFixed(3);
            });
            
            document.getElementById('depth-slider').addEventListener('input', function() {
                document.getElementById('depth-value').textContent = this.value;
            });
            
            document.getElementById('time-slider').addEventListener('input', function() {
                document.getElementById('time-value').textContent = parseFloat(this.value).toFixed(1);
            });
            
            document.getElementById('resolution-slider').addEventListener('input', function() {
                document.getElementById('resolution-value').textContent = this.value;
                simulation.spatialPoints = parseInt(this.value);
                resetSimulation();
            });
            
            document.getElementById('show-phase').addEventListener('change', updateVisualization);
            
            // Set up theory tabs
            document.querySelectorAll('.theory-tab').forEach(tab => {
                tab.addEventListener('click', function() {
                    // Remove active class from all tabs and contents
                    document.querySelectorAll('.theory-tab').forEach(t => t.classList.remove('active'));
                    document.querySelectorAll('.theory-content').forEach(c => c.classList.remove('active'));
                    
                    // Add active class to clicked tab and corresponding content
                    this.classList.add('active');
                    const tabId = this.getAttribute('data-tab');
                    document.getElementById(`${tabId}-content`).classList.add('active');
                });
            });
            
            // Initialize field and visualization
            initializeField();
            updateVisualization();
        }
        
        // Start simulation
        function startSimulation() {
            if (simulation.running) return;
            
            simulation.running = true;
            document.getElementById('start-btn').disabled = true;
            document.getElementById('pause-btn').disabled = false;
            
            simulation.animationId = requestAnimationFrame(updateField);
        }
        
        // Pause simulation
        function pauseSimulation() {
            if (!simulation.running) return;
            
            simulation.running = false;
            document.getElementById('start-btn').disabled = false;
            document.getElementById('pause-btn').disabled = true;
            
            if (simulation.animationId) {
                cancelAnimationFrame(simulation.animationId);
                simulation.animationId = null;
            }
        }
        
        // Reset simulation
        function resetSimulation() {
            pauseSimulation();
            simulation.time = 0;
            initializeField();
            updateVisualization();
        }
        
        // Initialize when page loads
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>